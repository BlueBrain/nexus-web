# Our JavaScript workflow

- lint code
- test code
- transpile code for server
- bundle code for client

## Transpiler and Bundler

Modern JavaScript based projects need two things:

- a transpiler that converts code from one form to a specific ECMA compatible version
- a bundler, that resolves module dependencies and create a single file for web browsers

### Transpiler

You can write JavaScript against the latest ECMA specification and convert it in order to target an old browser or an old version of Node.js.

One of the most famous transpiler is babel. It will convert things like:

```javascript
const add = (a, b) => a + b;
```

into (depending on your settings):

```javascript
function add(a, b) {
  return a + b;
}
```

You can can try it online using [Babel's playground](https://babeljs.io/en/repl)

In our case, we are using TypeScript's transpiler, which will convert TypeScript (TS) code into JavaScript (JS).

It will convert something like:

```typescript
function add(a: number, b: number): number {
  return a + b;
}
```

Into:

```javascript
function add(a, b) {
  return a + b;
}
```

Using a transpiler gives you several benefits:

- you can use the latest version of the language, with all the nice new syntax sugar
- you can configure it, so you can target an even older browser just by tweaking settings
- it does a static analysis of your code (with static type check in the case of TS) in order to prevent errors

In order to transpile our code, we are using TypeScript CLI interface:

```json
{
  "build:server": "tsc" // run tsc cli using our tsconfig.json config
}
```

### Bundler

For web browsers, we need to stitch all of the modules into a single bundle. This is when a bundler, such as webpack, rollup, browserify comes in.

It will transform something like:

```javascript
// in src/maths.js
export function add(a, b) {
  return a + b;
}

// in src/index.js
import { add } from './maths';
console.log(add(1, 2));
```

into:

```javascript
// in dist/bundle.js
function add(a, b) {
  return a + b;
}
console.log(add(1, 2));
```

They usually do some more advance operations, like tree-shaking for example, in order to minimise the final bundle size.

In order to bundle our code, we are using Webpack CLI interface:

```json
{
  "build:client": "webpack" // run webpack cli using our webpack.config.js config
}
```

## Server-side rendering (SSR)

In our case, we are doing server side rendering, which means we are rendering the HTML generated by our React app in the server first, and send that document to the client, along side the JS bundle so the browser can take over.

Our code structure looks like:

```
.
+-- server
|   +-- index.ts
+-- client
|   +-- index.ts
+-- shared
|   +-- index.ts
```

After we transpile and bundle, we end up with:

```
.
+-- server
|   +-- index.js
+-- public
|   +-- bundle.js
+-- shared
|   +-- index.js
```

## ts-node and Hot module replacement (HMR)

Being able to compile our application into runnable server/client code is cool, but running our tool chain on every change isn't ideal in term of development flow.

### ts-node

The [ts-node](https://github.com/TypeStrong/ts-node) CLI is like `node` CLI but is does TypeScript transpiling on the fly. The same way you can run `node index.js` on a JS file, you can run `ts-node index.ts` on a TS file. It is quite handy to be able to run our TS code directly, without compiling it first. This is a development too however an you should **not** use it in production. For babel-based project, you can use [babel-node](https://babeljs.io/docs/en/next/babel-node.html).

Combined with [nodemon](https://github.com/remy/nodemon), you can also restart your server when a file has been changed.

You start script would look like that:

```json
{
  "start": "nodemon server/index.ts --exec ts-node"
}
```

### HMR

On the client, traditionally we would take a similar approach with technologies such as _livereload_ but we don't want to reload the page _every time_ we have a new bundle. The reason for that is, bt reloading the page we loose the current context.

If you are editing a popup for example, you after to click on the button that triggers the popup after each reload, or if you are editing step 4 of a form, you have to complete step 1/2/3 before reaching your changes. You can partially solve this by having a very strict stateless application (reload /form/step/2) and re-hydrate the state of your app but if a particular part of your app is dependent on fetching data first, you'll make async calls on each reload (and that data might not be stateless, which means side effects can break your logic).

Instead what we can do is Hot Module Replacement, which will dynamically re-render your app, using the same state but with the new code, and dynamically replace it on the client. You can read more about HMR online, there are tons of articles about it.

[Webpack](https://webpack.js.org/concepts/hot-module-replacement/) does support HMR. You can set it up directly into your webpack config and using Webpack CLI, or you can use (webpack-hot-middleware)[https://github.com/webpack-contrib/webpack-hot-middleware] for express (the webserver framework we use).

Combined with [webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware), we can trigger our webpack build directly from our express, when we run in development mode.

```javascript
// our express app
const app = express();

// load webpack
const webpack = require('webpack');

// load our webpack the config
const webpackConfig = require('../../webpack.config');

// we need to overwrite and add a few things
const devConfig = {...webpackConfig, {
  mode: 'development',                    // mode is development (no minify, watch changes, etc...)
  entry: {...webpackConfig.entry, {
    bundle: [
      ...webpackConfig.entry.bundle,
      'webpack-hot-middleware/client',    // add hmr client js code to the bundle
    ],
  }},
  plugins: [
    ...webpackConfig.plugins,
    new webpack.HotModuleReplacementPlugin() // run the HMR plugin
  ],
}};

// create a new webpack compiler with our dev config
const compiler = webpack(devConfig);

// add the dev middleware (runs webpack when server starts)
app.use(require('webpack-dev-middleware')(compiler, {
  publicPath: '/public', // this needs to match the public path from our config.output.publicPath if set
}));

// add the HMR middleware
app.use(require('webpack-hot-middleware')(compiler, {
  path: '/__webpack_hmr',
  timeout: 20000,
}));
```

This means that for development, all we need to run is `ts-node server/index.ts`.

## Lint

We use [ts-lint]() with airbnb rules.

## Unit and Integration tests

We use [jest]() with [react-testing-library].

## End-to-End Testing

End-to-testing is implemented with [Cypress]('https://www.cypress.io/'). The [cypress-testing-library] paackage is used to support the same dom-testing queries as used in our unit and integration tests.

Cypress has a desktop application as well as a CLI. The desktop application is useful when browsing and debugging tests.

### Configuration

There are several Cypress environment variables that must be specified in order for the tests to run successfully

- **CYPRESS_AUTH_REALM** the auth realm to which to authenticate the specified nexus user
- **CYPRESS_AUTH_USERNAME** the Nexus username to use to authenticate
- **CYPRESS_AUTH_PASSWORD** the Nexus username password to use to authenticate
- **CYPRESS_NEXUS_API_URL** the url to the Nexus API for which the tests will be run. It is used as part of the setup and teardown process
- **CYPRESS_BASE_URL** _optional_ Defaults to http://localhost:8000
- **CYPRESS_ORG_LABEL** _optional_ Defaults to Cypress-Testing
- **CYPRESS_PROJECT_LABEL_BASE** _optional_ Defaults to e2e

### Cypress desktop app

Make sure the Nexus web app is running locally, then run:

```sh
CYPRESS_AUTH_REALM=https://auth.realm.url/ \
CYPRESS_AUTH_USERNAME=nexus_username \
CYPRESS_AUTH_PASSWORD=nexus_password \
CYPRESS_NEXUS_API_URL=https://nexusapi.url/v1 \
yarn cy:open --e2e --browser chrome
```

### CLI

Make sure the Nexus web app is running locally, then run:

```sh
CYPRESS_AUTH_REALM=https://auth.realm.url/ \
CYPRESS_AUTH_USERNAME=nexus_username \
CYPRESS_AUTH_PASSWORD=nexus_password \
CYPRESS_NEXUS_API_URL=https://nexusapi.url/v1 \
yarn cy:run --e2e --browser chrome
```

All of the tests will run in headless mode.
