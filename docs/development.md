# Our JavaScript workflow

- lint code
- test code
- transpile code for server
- transpile and bundle code for client

## Transpiler and Bundler

Modern JavaScript based projects need two things:

- a transpiler that converts code from one form to a specific ECMA compatible version
- a bundler, that resolves module dependencies and create a single file for web browsers

### Transpiler

You can write JavaScript against the latest ECMA specification and convert it in order to target an old browser or an old version of Node.js.

One of the most famous transpiler is babel. It will convert things like:

```javascript
const add = (a, b) => a + b;
```

into (depending on your settings):

```javascript
function add(a, b) {
  return a + b;
}
```

You can can try it online using [Babel's playground](https://babeljs.io/en/repl)

In our case, we are using TypeScript's transpiler, which will convert TypeScript (TS) code into JavaScript (JS).

It will convert something like:

```typescript
function add(a: number, b: number): number {
  return a + b;
}
```

Into:

```javascript
function add(a, b) {
  return a + b;
}
```

Using a transpiler gives you several benefits:

- you can use the latest version of the language, with all the nice new syntax sugar
- you can configure it, so you can target an even older browser just by tweaking settings
- it does a static analysis of your code (with static type check in the case of TS) in order to prevent errors

### Bundler

For web browsers, we need to stitch all of the modules into a single bundle. This is when a bundler, such as Webpack, Rollup, Browserify comes in.

It will transform something like:

```javascript
// in src/maths.js
export function add(a, b) {
  return a + b;
}

// in src/index.js
import { add } from './maths';
console.log(add(1, 2));
```

into:

```javascript
// in dist/bundle.js
function add(a, b) {
  return a + b;
}
console.log(add(1, 2));
```

They usually do some more advance operations, like tree-shaking for example, in order to minimise the final bundle size.

## Server-side rendering (SSR)

In our case, we are doing server side rendering, which means we are rendering the HTML generated by our React app in the server first, and send that document to the client, along side the JS bundle so the browser can take over.

Our code structure looks like:

```txt
.
+-- server
| +-- index.ts
+-- client
| +-- index.ts
+-- shared
| +-- index.ts

```

After we transpile and bundle, we end up with:

```txt
.
+-- server
| +-- index.js
+-- public
| +-- bundle.js
+-- shared
| +-- index.js

```

## ts-node and Hot module replacement (HMR)

Being able to compile our application into runnable server/client code is cool, but running our tool chain on every change isn't ideal in term of development flow.

### ts-node

The [ts-node](https://github.com/TypeStrong/ts-node) CLI is like `node` CLI but is does TypeScript transpiling on the fly. The same way you can run `node index.js` on a JS file, you can run `ts-node index.ts` on a TS file. It is quite handy to be able to run our TS code directly, without compiling it first. This is a development too however an you should **not** use it in production. For babel-based project, you can use [babel-node](https://babeljs.io/docs/en/next/babel-node.html).

Combined with [nodemon](https://github.com/remy/nodemon), you can also restart your server when a file has been changed.

You start script would look like that:

```json
{
  "start": "nodemon server/index.ts --exec ts-node"
}
```

### HMR

On the client, traditionally we would take a similar approach with technologies such as _livereload_ but we don't want to reload the page _every time_ we have a new bundle. The reason for that is, bt reloading the page we loose the current context.

If you are editing a popup for example, you after to click on the button that triggers the popup after each reload, or if you are editing step 4 of a form, you have to complete step 1/2/3 before reaching your changes. You can partially solve this by having a very strict stateless application (reload /form/step/2) and re-hydrate the state of your app but if a particular part of your app is dependent on fetching data first, you'll make async calls on each reload (and that data might not be stateless, which means side effects can break your logic).

Instead what we can do is Hot Module Replacement, which will dynamically re-render your app, using the same state but with the new code, and dynamically replace it on the client. You can read more about HMR online, there are tons of articles about it.

[Webpack](https://webpack.js.org/concepts/hot-module-replacement/) does support HMR. You can set it up directly into your webpack config and using Webpack CLI, or you can use [webpack-hot-middleware](https://github.com/webpack-contrib/webpack-hot-middleware) for express (the web server framework we use).

Combined with [webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware), we can trigger our webpack build directly from our express, when we run in development mode.

```javascript
// our express app
const app = express();

// load webpack
const webpack = require('webpack');

// load our webpack the config
const webpackConfig = require('../../webpack.config');

// we need to overwrite and add a few things
const devConfig = {...webpackConfig, {
  mode: 'development',                    // mode is development (no minify, watch changes, etc...)
  entry: {...webpackConfig.entry, {
    bundle: [
      ...webpackConfig.entry.bundle,
      'webpack-hot-middleware/client',    // add hmr client js code to the bundle
    ],
  }},
  plugins: [
    ...webpackConfig.plugins,
    new webpack.HotModuleReplacementPlugin() // run the HMR plugin
  ],
}};

// create a new webpack compiler with our dev config
const compiler = webpack(devConfig);

// add the dev middleware (runs webpack when server starts)
app.use(require('webpack-dev-middleware')(compiler, {
  publicPath: '/public', // this needs to match the public path from our config.output.publicPath if set
}));

// add the HMR middleware
app.use(require('webpack-hot-middleware')(compiler, {
  path: '/__webpack_hmr',
  timeout: 20000,
}));
```

This means that for development, all we need to run is `ts-node server/index.ts`.

## Lint

We use `ts-lint`` with Airbnb rules.

## Unit and Integration tests

We use `jest` with `react-testing-library``.

## End-to-End Testing

End-to-testing is implemented with [Cypress]('https://www.cypress.io'). The `cypress-testing-library`` package is used to support the same dom-testing queries as used in our unit and integration tests.

Cypress has a desktop application as well as a CLI. The desktop application is useful when browsing and debugging tests.

### Configuration

There are several Cypress environment variables that must be specified in order for the tests to run successfully. The cypress.env.json.sample includes these variables. Rename the file to cypress.env.json in order for it be picked up by Cypress and set the variables appropriately. Note that if you specify any Cypress variable at the command line it must be prefixed with CYPRESS\_ and it will override any variables set in the cypress.env.json file.

- **use_existing_delta_instance** whether to use an existing instance of Delta or a new one is being set-up
- **NEXUS_API_URL** the url to the Nexus API for which the tests will be run. It is used as part of the setup and teardown process
- **BASE_URL** _optional_ Defaults to <http://localhost:8000>
- **ORG_LABEL** _optional_ Defaults to Cypress-Testing
- **PROJECT_LABEL_BASE** _optional_ Defaults to e2e

### Cypress desktop app

Make sure the Nexus web app is running locally, then run:

```sh
CYPRESS_AUTH_REALM=https://auth.realm.url/ \
CYPRESS_AUTH_USERNAME=nexus_username \
CYPRESS_AUTH_PASSWORD=nexus_password \
CYPRESS_NEXUS_API_URL=https://nexusapi.url/v1 \
yarn cy:open --e2e --browser chrome
```

### CLI

Make sure the Nexus web app is running locally, then run:

```sh
CYPRESS_AUTH_REALM=https://auth.realm.url/ \
CYPRESS_AUTH_USERNAME=nexus_username \
CYPRESS_AUTH_PASSWORD=nexus_password \
CYPRESS_NEXUS_API_URL=https://nexusapi.url/v1 \
yarn cy:run --e2e --browser chrome
```

All of the tests will run in headless mode.

## Debugging End-to-End test failures in CI

There are a few differences between how our e2e tests run in the ci compared to how we run it locally. We use different instances of delta, Postgres, Keycloak etc in these two environments. Also, the version of chrome you may have locally might differ from the version of chrome being used in the ci. Finally, the machine cpu, memory are also most likely different. This can make debugging test failures in ci difficult.

The videos and screenshots of tests are uploaded to [cypress cloud](https://cloud.cypress.io). If these are not sufficient to debug the issue, follow along.

1. Remove your `node_modules`` folder locally and reinstall the dependencies to be sure that they are exactly the same as in ci:

```sh
rm -rf node_modules
yarn install --frozen-lockfile
```

2. Create the image for fusion:

```sh
sudo docker build . --tag=nexus-web:fresh
```

You may need to run the above command with sudo privileges

3. [Optional] You may want to mount your local code inside the container. This will allow you to make changes and see their results quickly, as opposed to make changes, copy the changes into the container, and then see their results. You'll need to update the `cypress` service section inside your `docker-compose.yml` for this:

```sh
  cypress:
    image: 'cypress/included:12.17.0'
    volumes:   # This is the change
      - ../:/e2e
    user: ${CYPRESS_USER} # You can also set a user here to avoid issues with file permissions. This is optional.
```

4. Start services defined in docker-compose file:

If you followed step 3:

```sh
CYPRESS_USER=$UID sudo --preserve-env=CYPRESS_USER docker-compose -f ci/docker-compose.yml up -d
```

Otherwise:

```sh
sudo docker compose -f ci/docker-compose.yml up -d
sudo docker cp ./. cypress:/e2e
```

5. Run the tests as they would in ci:

```sh
yarn run cy:ci
```

6. You can also navigate to <http://fusion.test:8000> in your browser to see the same instance of fusion that cypress is testing.

7. Remember to stop the services once done:

```sh
sudo docker-compose -f ci/docker-compose.yml down --rmi "local" --volumes
```
